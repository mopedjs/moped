// generated by ts-bicycle
// do not edit by hand

import {
  BaseRootQuery,
  addField,
  merge,
  BaseQuery,
  Mutation,
} from 'bicycle/typed-helpers/query';
import {RootCache, GetOptimisticValue} from './optimistic';
import * as ScalarTypes from './scalar-types';

export class RootQuery<TResult = {}> extends BaseRootQuery<TResult> {
  // fields
  user<TUser>(
    User: UserQuery<TUser>,
  ): RootQuery<TResult & {user: null | TUser}> {
    return new RootQuery(addField(this._query, 'user', (User as any)._query));
  }
  users<TUser>(User: UserQuery<TUser>): RootQuery<TResult & {users: TUser[]}> {
    return new RootQuery(addField(this._query, 'users', (User as any)._query));
  }

  merge<TOther>(other: RootQuery<TOther>): RootQuery<TResult & TOther> {
    return new RootQuery(merge(this._query, other._query));
  }

  // mutations
}
export class UserQuery<TResult = {}> extends BaseQuery<TResult> {
  // fields
  get id(): UserQuery<TResult & {id: number}> {
    return new UserQuery(addField(this._query, 'id', true));
  }
  get name(): UserQuery<TResult & {name: string}> {
    return new UserQuery(addField(this._query, 'name', true));
  }
  get privateStatus(): UserQuery<TResult & {privateStatus: string}> {
    return new UserQuery(addField(this._query, 'privateStatus', true));
  }
  get publicStatus(): UserQuery<TResult & {publicStatus: string}> {
    return new UserQuery(addField(this._query, 'publicStatus', true));
  }

  merge<TOther>(other: UserQuery<TOther>): UserQuery<TResult & TOther> {
    return new UserQuery(merge(this._query, other._query));
  }

  // mutations
  createPasswordlessToken(
    args: {email: string; state: {redirectURL: string}},
    optimisticUpdate?: (
      mutation: {
        objectName: 'User';
        methodName: 'createPasswordlessToken';
        args: {email: string; state: {redirectURL: string}};
      },
      cache: RootCache,
      getOptimisticValue: GetOptimisticValue,
    ) => any,
  ): Mutation<
    | {
        dos: string;
        kind: ScalarTypes.CreateTokenStatusKind.CreatedToken;
        tokenID: string;
      }
    | {
        email: string;
        kind: ScalarTypes.CreateTokenStatusKind.InvalidEmail;
        message: string;
      }
    | {
        kind: ScalarTypes.CreateTokenStatusKind.RateLimitExceeded;
        message: string;
        nextTokenTimestamp: number;
      }
  > {
    return new Mutation(
      'User.createPasswordlessToken',
      args,
      optimisticUpdate as any,
    );
  }
  logout(
    optimisticUpdate?: (
      mutation: {objectName: 'User'; methodName: 'logout'; args: void},
      cache: RootCache,
      getOptimisticValue: GetOptimisticValue,
    ) => any,
  ): Mutation<void> {
    return new Mutation('User.logout', undefined, optimisticUpdate as any);
  }
  setName(
    args: string,
    optimisticUpdate?: (
      mutation: {objectName: 'User'; methodName: 'setName'; args: string},
      cache: RootCache,
      getOptimisticValue: GetOptimisticValue,
    ) => any,
  ): Mutation<void> {
    return new Mutation('User.setName', args, optimisticUpdate as any);
  }
  setPrivateStatus(
    args: string,
    optimisticUpdate?: (
      mutation: {
        objectName: 'User';
        methodName: 'setPrivateStatus';
        args: string;
      },
      cache: RootCache,
      getOptimisticValue: GetOptimisticValue,
    ) => any,
  ): Mutation<void> {
    return new Mutation('User.setPrivateStatus', args, optimisticUpdate as any);
  }
  setPublicStatus(
    args: string,
    optimisticUpdate?: (
      mutation: {
        objectName: 'User';
        methodName: 'setPublicStatus';
        args: string;
      },
      cache: RootCache,
      getOptimisticValue: GetOptimisticValue,
    ) => any,
  ): Mutation<void> {
    return new Mutation('User.setPublicStatus', args, optimisticUpdate as any);
  }
  verifyPasswordlessToken(
    args: string,
    optimisticUpdate?: (
      mutation: {
        objectName: 'User';
        methodName: 'verifyPasswordlessToken';
        args: string;
      },
      cache: RootCache,
      getOptimisticValue: GetOptimisticValue,
    ) => any,
  ): Mutation<
    | {
        kind: ScalarTypes.VerifyPassCodeStatusKind.CorrectPassCode;
        userID: string;
      }
    | {
        kind: ScalarTypes.VerifyPassCodeStatusKind.ExpiredToken;
        message: string;
      }
    | {
        attemptsRemaining: number;
        kind: ScalarTypes.VerifyPassCodeStatusKind.IncorrectPassCode;
        message: string;
      }
    | {
        kind: ScalarTypes.VerifyPassCodeStatusKind.RateLimitExceeded;
        message: string;
        nextTokenTimestamp: number;
      }
  > {
    return new Mutation(
      'User.verifyPasswordlessToken',
      args,
      optimisticUpdate as any,
    );
  }
}
