// Auto generated by @moped/db-schema - do not edit by hand

import sql, {SQLQuery} from '@moped/sql';
import MopedMigrations from './tables/MopedMigrations';
import MopedMigrationsVersion from './tables/MopedMigrationsVersion';
import RateLimitStates from './tables/RateLimitStates';
import Sessions from './tables/Sessions';
import Tokens from './tables/Tokens';
import UserEmails from './tables/UserEmails';
import Users from './tables/Users';
import numbers from './tables/numbers';

function getOneResult<T>(results: T[]): T | null {
  if (results.length === 0) {
    return null;
  }
  if (results.length === 1) {
    return results[0];
  }
  throw new Error(
    'Expected either one result, or no results to be returned from this query',
  );
}
function noop(): void {}
export interface Connection {
  query(query: SQLQuery): Promise<any[]>;
  task<T>(fn: (connection: Connection) => Promise<T>): Promise<T>;
  tx<T>(fn: (connection: Connection) => Promise<T>): Promise<T>;
}
export class APIBase {
  protected db: Connection;
  constructor(db: Connection) {
    this.db = db;
  }
}

export class MopedMigrationsAPI extends APIBase {
  create(mopedMigrations: {
    id: MopedMigrations['id'];
    index: MopedMigrations['index'];
    isApplied?: MopedMigrations['isApplied'];
    lastDown?: MopedMigrations['lastDown'];
    lastUp?: MopedMigrations['lastUp'];
    name: MopedMigrations['name'];
  }): Promise<MopedMigrations> {
    const columns = Object.keys(mopedMigrations)
      .sort()
      .filter(
        name =>
          name === 'id' ||
          name === 'index' ||
          name === 'isApplied' ||
          name === 'lastDown' ||
          name === 'lastUp' ||
          name === 'name',
      )
      .map(name => ({name, value: (mopedMigrations as any)[name]}));
    const data = columns.length
      ? sql`(${sql.join(
          columns.map(c => sql.ident(c.name)),
          ',',
        )}) VALUES (${sql.join(columns.map(c => sql`${c.value}`), ',')})`
      : sql`DEFAULT VALUES`;
    let s = sql`INSERT INTO "MopedMigrations" ${data} RETURNING *;`;
    return this.db.query(s).then(results => results[0]);
  }

  where(query: SQLQuery): Promise<MopedMigrations[]> {
    return this.db.query(
      sql.join([sql`SELECT * FROM "MopedMigrations"`, query], ' WHERE '),
    );
  }

  list(query?: Partial<MopedMigrations>): Promise<MopedMigrations[]> {
    if (query === undefined) {
      return this.db.query(sql`SELECT * FROM "MopedMigrations"`);
    }
    return this.where(
      sql.join(
        Object.keys(query)
          .sort()
          .filter(
            fieldName =>
              fieldName === 'id' ||
              fieldName === 'index' ||
              fieldName === 'isApplied' ||
              fieldName === 'lastDown' ||
              fieldName === 'lastUp' ||
              fieldName === 'name',
          )
          .map(field => sql`${sql.ident(field)} = ${(query as any)[field]}`),
        ' AND ',
      ),
    );
  }

  get(
    id: MopedMigrations['id'],
    query?: {
      index?: MopedMigrations['index'];
      isApplied?: MopedMigrations['isApplied'];
      lastDown?: MopedMigrations['lastDown'];
      lastUp?: MopedMigrations['lastUp'];
      name?: MopedMigrations['name'];
    },
  ): Promise<MopedMigrations | null> {
    if (query === undefined) {
      return this.db
        .query(sql`SELECT * FROM "MopedMigrations" WHERE "id" = ${id}`)
        .then(getOneResult);
    }
    return this.db
      .query(
        sql.join(
          [sql`SELECT * FROM "MopedMigrations" WHERE "id" = ${id}`].concat(
            Object.keys(query)
              .sort()
              .filter(
                fieldName =>
                  fieldName === 'index' ||
                  fieldName === 'isApplied' ||
                  fieldName === 'lastDown' ||
                  fieldName === 'lastUp' ||
                  fieldName === 'name',
              )
              .map(
                field => sql`${sql.ident(field)} = ${(query as any)[field]}`,
              ),
          ),
          ' AND ',
        ),
      )
      .then(getOneResult);
  }

  update(
    id: MopedMigrations['id'],
    mopedMigrations: {
      index?: MopedMigrations['index'];
      isApplied?: MopedMigrations['isApplied'];
      lastDown?: MopedMigrations['lastDown'];
      lastUp?: MopedMigrations['lastUp'];
      name?: MopedMigrations['name'];
    },
    query?: {
      index?: MopedMigrations['index'];
      isApplied?: MopedMigrations['isApplied'];
      lastDown?: MopedMigrations['lastDown'];
      lastUp?: MopedMigrations['lastUp'];
      name?: MopedMigrations['name'];
    },
  ): Promise<void> {
    const updateColumns = sql.join(
      Object.keys(mopedMigrations)
        .sort()
        .filter(
          fieldName =>
            fieldName === 'index' ||
            fieldName === 'isApplied' ||
            fieldName === 'lastDown' ||
            fieldName === 'lastUp' ||
            fieldName === 'name',
        )
        .map(
          field =>
            sql`${sql.ident(field)} = ${(mopedMigrations as any)[field]}`,
        ),
      ', ',
    );

    if (query === undefined) {
      return this.db
        .query(
          sql`UPDATE "MopedMigrations" SET ${updateColumns} WHERE "id" = ${id}`,
        )
        .then(noop);
    }
    return this.db
      .query(
        sql.join(
          [
            sql`UPDATE "MopedMigrations" SET ${updateColumns} WHERE "id" = ${id}`,
          ].concat(
            Object.keys(query)
              .sort()
              .filter(
                fieldName =>
                  fieldName === 'index' ||
                  fieldName === 'isApplied' ||
                  fieldName === 'lastDown' ||
                  fieldName === 'lastUp' ||
                  fieldName === 'name',
              )
              .map(
                field => sql`${sql.ident(field)} = ${(query as any)[field]}`,
              ),
          ),
          ' AND ',
        ),
      )
      .then(noop);
  }

  remove(
    id: MopedMigrations['id'],
    query?: {
      index?: MopedMigrations['index'];
      isApplied?: MopedMigrations['isApplied'];
      lastDown?: MopedMigrations['lastDown'];
      lastUp?: MopedMigrations['lastUp'];
      name?: MopedMigrations['name'];
    },
  ): Promise<void> {
    if (!query) {
      return this.db
        .query(sql`DELETE FROM "MopedMigrations" WHERE "id" = ${id}`)
        .then(noop);
    }
    return this.db
      .query(
        sql.join(
          [sql`DELETE FROM "MopedMigrations" WHERE "id" = ${id}`].concat(
            Object.keys(query)
              .sort()
              .filter(
                fieldName =>
                  fieldName === 'index' ||
                  fieldName === 'isApplied' ||
                  fieldName === 'lastDown' ||
                  fieldName === 'lastUp' ||
                  fieldName === 'name',
              )
              .map(
                field => sql`${sql.ident(field)} = ${(query as any)[field]}`,
              ),
          ),
          ' AND ',
        ),
      )
      .then(noop);
  }
}

export class MopedMigrationsVersionAPI extends APIBase {
  create(mopedMigrationsVersion: {
    id: MopedMigrationsVersion['id'];
    version?: MopedMigrationsVersion['version'];
  }): Promise<MopedMigrationsVersion> {
    const columns = Object.keys(mopedMigrationsVersion)
      .sort()
      .filter(name => name === 'id' || name === 'version')
      .map(name => ({name, value: (mopedMigrationsVersion as any)[name]}));
    const data = columns.length
      ? sql`(${sql.join(
          columns.map(c => sql.ident(c.name)),
          ',',
        )}) VALUES (${sql.join(columns.map(c => sql`${c.value}`), ',')})`
      : sql`DEFAULT VALUES`;
    let s = sql`INSERT INTO "MopedMigrationsVersion" ${data} RETURNING *;`;
    return this.db.query(s).then(results => results[0]);
  }

  where(query: SQLQuery): Promise<MopedMigrationsVersion[]> {
    return this.db.query(
      sql.join([sql`SELECT * FROM "MopedMigrationsVersion"`, query], ' WHERE '),
    );
  }

  list(
    query?: Partial<MopedMigrationsVersion>,
  ): Promise<MopedMigrationsVersion[]> {
    if (query === undefined) {
      return this.db.query(sql`SELECT * FROM "MopedMigrationsVersion"`);
    }
    return this.where(
      sql.join(
        Object.keys(query)
          .sort()
          .filter(fieldName => fieldName === 'id' || fieldName === 'version')
          .map(field => sql`${sql.ident(field)} = ${(query as any)[field]}`),
        ' AND ',
      ),
    );
  }

  get(
    id: MopedMigrationsVersion['id'],
    query?: {version?: MopedMigrationsVersion['version']},
  ): Promise<MopedMigrationsVersion | null> {
    if (query === undefined) {
      return this.db
        .query(sql`SELECT * FROM "MopedMigrationsVersion" WHERE "id" = ${id}`)
        .then(getOneResult);
    }
    return this.db
      .query(
        sql.join(
          [
            sql`SELECT * FROM "MopedMigrationsVersion" WHERE "id" = ${id}`,
          ].concat(
            Object.keys(query)
              .sort()
              .filter(fieldName => fieldName === 'version')
              .map(
                field => sql`${sql.ident(field)} = ${(query as any)[field]}`,
              ),
          ),
          ' AND ',
        ),
      )
      .then(getOneResult);
  }

  update(
    id: MopedMigrationsVersion['id'],
    mopedMigrationsVersion: {version?: MopedMigrationsVersion['version']},
    query?: {version?: MopedMigrationsVersion['version']},
  ): Promise<void> {
    const updateColumns = sql.join(
      Object.keys(mopedMigrationsVersion)
        .sort()
        .filter(fieldName => fieldName === 'version')
        .map(
          field =>
            sql`${sql.ident(field)} = ${
              (mopedMigrationsVersion as any)[field]
            }`,
        ),
      ', ',
    );

    if (query === undefined) {
      return this.db
        .query(
          sql`UPDATE "MopedMigrationsVersion" SET ${updateColumns} WHERE "id" = ${id}`,
        )
        .then(noop);
    }
    return this.db
      .query(
        sql.join(
          [
            sql`UPDATE "MopedMigrationsVersion" SET ${updateColumns} WHERE "id" = ${id}`,
          ].concat(
            Object.keys(query)
              .sort()
              .filter(fieldName => fieldName === 'version')
              .map(
                field => sql`${sql.ident(field)} = ${(query as any)[field]}`,
              ),
          ),
          ' AND ',
        ),
      )
      .then(noop);
  }

  remove(
    id: MopedMigrationsVersion['id'],
    query?: {version?: MopedMigrationsVersion['version']},
  ): Promise<void> {
    if (!query) {
      return this.db
        .query(sql`DELETE FROM "MopedMigrationsVersion" WHERE "id" = ${id}`)
        .then(noop);
    }
    return this.db
      .query(
        sql.join(
          [sql`DELETE FROM "MopedMigrationsVersion" WHERE "id" = ${id}`].concat(
            Object.keys(query)
              .sort()
              .filter(fieldName => fieldName === 'version')
              .map(
                field => sql`${sql.ident(field)} = ${(query as any)[field]}`,
              ),
          ),
          ' AND ',
        ),
      )
      .then(noop);
  }
}

export class RateLimitStatesAPI extends APIBase {
  create(rateLimitStates: {
    id: RateLimitStates['id'];
    timestamp: RateLimitStates['timestamp'];
    value: RateLimitStates['value'];
  }): Promise<RateLimitStates> {
    const columns = Object.keys(rateLimitStates)
      .sort()
      .filter(name => name === 'id' || name === 'timestamp' || name === 'value')
      .map(name => ({name, value: (rateLimitStates as any)[name]}));
    const data = columns.length
      ? sql`(${sql.join(
          columns.map(c => sql.ident(c.name)),
          ',',
        )}) VALUES (${sql.join(columns.map(c => sql`${c.value}`), ',')})`
      : sql`DEFAULT VALUES`;
    let s = sql`INSERT INTO "RateLimitStates" ${data} RETURNING *;`;
    return this.db.query(s).then(results => results[0]);
  }

  where(query: SQLQuery): Promise<RateLimitStates[]> {
    return this.db.query(
      sql.join([sql`SELECT * FROM "RateLimitStates"`, query], ' WHERE '),
    );
  }

  list(query?: Partial<RateLimitStates>): Promise<RateLimitStates[]> {
    if (query === undefined) {
      return this.db.query(sql`SELECT * FROM "RateLimitStates"`);
    }
    return this.where(
      sql.join(
        Object.keys(query)
          .sort()
          .filter(
            fieldName =>
              fieldName === 'id' ||
              fieldName === 'timestamp' ||
              fieldName === 'value',
          )
          .map(field => sql`${sql.ident(field)} = ${(query as any)[field]}`),
        ' AND ',
      ),
    );
  }

  get(
    id: RateLimitStates['id'],
    query?: {
      timestamp?: RateLimitStates['timestamp'];
      value?: RateLimitStates['value'];
    },
  ): Promise<RateLimitStates | null> {
    if (query === undefined) {
      return this.db
        .query(sql`SELECT * FROM "RateLimitStates" WHERE "id" = ${id}`)
        .then(getOneResult);
    }
    return this.db
      .query(
        sql.join(
          [sql`SELECT * FROM "RateLimitStates" WHERE "id" = ${id}`].concat(
            Object.keys(query)
              .sort()
              .filter(
                fieldName => fieldName === 'timestamp' || fieldName === 'value',
              )
              .map(
                field => sql`${sql.ident(field)} = ${(query as any)[field]}`,
              ),
          ),
          ' AND ',
        ),
      )
      .then(getOneResult);
  }

  update(
    id: RateLimitStates['id'],
    rateLimitStates: {
      timestamp?: RateLimitStates['timestamp'];
      value?: RateLimitStates['value'];
    },
    query?: {
      timestamp?: RateLimitStates['timestamp'];
      value?: RateLimitStates['value'];
    },
  ): Promise<void> {
    const updateColumns = sql.join(
      Object.keys(rateLimitStates)
        .sort()
        .filter(fieldName => fieldName === 'timestamp' || fieldName === 'value')
        .map(
          field =>
            sql`${sql.ident(field)} = ${(rateLimitStates as any)[field]}`,
        ),
      ', ',
    );

    if (query === undefined) {
      return this.db
        .query(
          sql`UPDATE "RateLimitStates" SET ${updateColumns} WHERE "id" = ${id}`,
        )
        .then(noop);
    }
    return this.db
      .query(
        sql.join(
          [
            sql`UPDATE "RateLimitStates" SET ${updateColumns} WHERE "id" = ${id}`,
          ].concat(
            Object.keys(query)
              .sort()
              .filter(
                fieldName => fieldName === 'timestamp' || fieldName === 'value',
              )
              .map(
                field => sql`${sql.ident(field)} = ${(query as any)[field]}`,
              ),
          ),
          ' AND ',
        ),
      )
      .then(noop);
  }

  remove(
    id: RateLimitStates['id'],
    query?: {
      timestamp?: RateLimitStates['timestamp'];
      value?: RateLimitStates['value'];
    },
  ): Promise<void> {
    if (!query) {
      return this.db
        .query(sql`DELETE FROM "RateLimitStates" WHERE "id" = ${id}`)
        .then(noop);
    }
    return this.db
      .query(
        sql.join(
          [sql`DELETE FROM "RateLimitStates" WHERE "id" = ${id}`].concat(
            Object.keys(query)
              .sort()
              .filter(
                fieldName => fieldName === 'timestamp' || fieldName === 'value',
              )
              .map(
                field => sql`${sql.ident(field)} = ${(query as any)[field]}`,
              ),
          ),
          ' AND ',
        ),
      )
      .then(noop);
  }
}

export class SessionsAPI extends APIBase {
  create(sessions: {
    created: Sessions['created'];
    id?: Sessions['id'];
    lastSeen: Sessions['lastSeen'];
    userAgent?: Sessions['userAgent'];
    userID: Sessions['userID'];
  }): Promise<Sessions> {
    const columns = Object.keys(sessions)
      .sort()
      .filter(
        name =>
          name === 'created' ||
          name === 'id' ||
          name === 'lastSeen' ||
          name === 'userAgent' ||
          name === 'userID',
      )
      .map(name => ({name, value: (sessions as any)[name]}));
    const data = columns.length
      ? sql`(${sql.join(
          columns.map(c => sql.ident(c.name)),
          ',',
        )}) VALUES (${sql.join(columns.map(c => sql`${c.value}`), ',')})`
      : sql`DEFAULT VALUES`;
    let s = sql`INSERT INTO "Sessions" ${data} RETURNING *;`;
    return this.db.query(s).then(results => results[0]);
  }

  where(query: SQLQuery): Promise<Sessions[]> {
    return this.db.query(
      sql.join([sql`SELECT * FROM "Sessions"`, query], ' WHERE '),
    );
  }

  list(query?: Partial<Sessions>): Promise<Sessions[]> {
    if (query === undefined) {
      return this.db.query(sql`SELECT * FROM "Sessions"`);
    }
    return this.where(
      sql.join(
        Object.keys(query)
          .sort()
          .filter(
            fieldName =>
              fieldName === 'created' ||
              fieldName === 'id' ||
              fieldName === 'lastSeen' ||
              fieldName === 'userAgent' ||
              fieldName === 'userID',
          )
          .map(field => sql`${sql.ident(field)} = ${(query as any)[field]}`),
        ' AND ',
      ),
    );
  }

  get(
    id: Sessions['id'],
    query?: {
      created?: Sessions['created'];
      lastSeen?: Sessions['lastSeen'];
      userAgent?: Sessions['userAgent'];
      userID?: Sessions['userID'];
    },
  ): Promise<Sessions | null> {
    if (query === undefined) {
      return this.db
        .query(sql`SELECT * FROM "Sessions" WHERE "id" = ${id}`)
        .then(getOneResult);
    }
    return this.db
      .query(
        sql.join(
          [sql`SELECT * FROM "Sessions" WHERE "id" = ${id}`].concat(
            Object.keys(query)
              .sort()
              .filter(
                fieldName =>
                  fieldName === 'created' ||
                  fieldName === 'lastSeen' ||
                  fieldName === 'userAgent' ||
                  fieldName === 'userID',
              )
              .map(
                field => sql`${sql.ident(field)} = ${(query as any)[field]}`,
              ),
          ),
          ' AND ',
        ),
      )
      .then(getOneResult);
  }

  update(
    id: Sessions['id'],
    sessions: {
      created?: Sessions['created'];
      lastSeen?: Sessions['lastSeen'];
      userAgent?: Sessions['userAgent'];
      userID?: Sessions['userID'];
    },
    query?: {
      created?: Sessions['created'];
      lastSeen?: Sessions['lastSeen'];
      userAgent?: Sessions['userAgent'];
      userID?: Sessions['userID'];
    },
  ): Promise<void> {
    const updateColumns = sql.join(
      Object.keys(sessions)
        .sort()
        .filter(
          fieldName =>
            fieldName === 'created' ||
            fieldName === 'lastSeen' ||
            fieldName === 'userAgent' ||
            fieldName === 'userID',
        )
        .map(field => sql`${sql.ident(field)} = ${(sessions as any)[field]}`),
      ', ',
    );

    if (query === undefined) {
      return this.db
        .query(sql`UPDATE "Sessions" SET ${updateColumns} WHERE "id" = ${id}`)
        .then(noop);
    }
    return this.db
      .query(
        sql.join(
          [
            sql`UPDATE "Sessions" SET ${updateColumns} WHERE "id" = ${id}`,
          ].concat(
            Object.keys(query)
              .sort()
              .filter(
                fieldName =>
                  fieldName === 'created' ||
                  fieldName === 'lastSeen' ||
                  fieldName === 'userAgent' ||
                  fieldName === 'userID',
              )
              .map(
                field => sql`${sql.ident(field)} = ${(query as any)[field]}`,
              ),
          ),
          ' AND ',
        ),
      )
      .then(noop);
  }

  remove(
    id: Sessions['id'],
    query?: {
      created?: Sessions['created'];
      lastSeen?: Sessions['lastSeen'];
      userAgent?: Sessions['userAgent'];
      userID?: Sessions['userID'];
    },
  ): Promise<void> {
    if (!query) {
      return this.db
        .query(sql`DELETE FROM "Sessions" WHERE "id" = ${id}`)
        .then(noop);
    }
    return this.db
      .query(
        sql.join(
          [sql`DELETE FROM "Sessions" WHERE "id" = ${id}`].concat(
            Object.keys(query)
              .sort()
              .filter(
                fieldName =>
                  fieldName === 'created' ||
                  fieldName === 'lastSeen' ||
                  fieldName === 'userAgent' ||
                  fieldName === 'userID',
              )
              .map(
                field => sql`${sql.ident(field)} = ${(query as any)[field]}`,
              ),
          ),
          ' AND ',
        ),
      )
      .then(noop);
  }
}

export class TokensAPI extends APIBase {
  create(tokens: {
    attemptsRemaining: Tokens['attemptsRemaining'];
    created: Tokens['created'];
    dos: Tokens['dos'];
    email: Tokens['email'];
    expiry: Tokens['expiry'];
    id?: Tokens['id'];
    passCodeHash: Tokens['passCodeHash'];
    state: Tokens['state'];
    userAgent: Tokens['userAgent'];
  }): Promise<Tokens> {
    const columns = Object.keys(tokens)
      .sort()
      .filter(
        name =>
          name === 'attemptsRemaining' ||
          name === 'created' ||
          name === 'dos' ||
          name === 'email' ||
          name === 'expiry' ||
          name === 'id' ||
          name === 'passCodeHash' ||
          name === 'state' ||
          name === 'userAgent',
      )
      .map(name => ({name, value: (tokens as any)[name]}));
    const data = columns.length
      ? sql`(${sql.join(
          columns.map(c => sql.ident(c.name)),
          ',',
        )}) VALUES (${sql.join(columns.map(c => sql`${c.value}`), ',')})`
      : sql`DEFAULT VALUES`;
    let s = sql`INSERT INTO "Tokens" ${data} RETURNING *;`;
    return this.db.query(s).then(results => results[0]);
  }

  where(query: SQLQuery): Promise<Tokens[]> {
    return this.db.query(
      sql.join([sql`SELECT * FROM "Tokens"`, query], ' WHERE '),
    );
  }

  list(query?: Partial<Tokens>): Promise<Tokens[]> {
    if (query === undefined) {
      return this.db.query(sql`SELECT * FROM "Tokens"`);
    }
    return this.where(
      sql.join(
        Object.keys(query)
          .sort()
          .filter(
            fieldName =>
              fieldName === 'attemptsRemaining' ||
              fieldName === 'created' ||
              fieldName === 'dos' ||
              fieldName === 'email' ||
              fieldName === 'expiry' ||
              fieldName === 'id' ||
              fieldName === 'passCodeHash' ||
              fieldName === 'state' ||
              fieldName === 'userAgent',
          )
          .map(field => sql`${sql.ident(field)} = ${(query as any)[field]}`),
        ' AND ',
      ),
    );
  }

  get(
    id: Tokens['id'],
    query?: {
      attemptsRemaining?: Tokens['attemptsRemaining'];
      created?: Tokens['created'];
      dos?: Tokens['dos'];
      email?: Tokens['email'];
      expiry?: Tokens['expiry'];
      passCodeHash?: Tokens['passCodeHash'];
      state?: Tokens['state'];
      userAgent?: Tokens['userAgent'];
    },
  ): Promise<Tokens | null> {
    if (query === undefined) {
      return this.db
        .query(sql`SELECT * FROM "Tokens" WHERE "id" = ${id}`)
        .then(getOneResult);
    }
    return this.db
      .query(
        sql.join(
          [sql`SELECT * FROM "Tokens" WHERE "id" = ${id}`].concat(
            Object.keys(query)
              .sort()
              .filter(
                fieldName =>
                  fieldName === 'attemptsRemaining' ||
                  fieldName === 'created' ||
                  fieldName === 'dos' ||
                  fieldName === 'email' ||
                  fieldName === 'expiry' ||
                  fieldName === 'passCodeHash' ||
                  fieldName === 'state' ||
                  fieldName === 'userAgent',
              )
              .map(
                field => sql`${sql.ident(field)} = ${(query as any)[field]}`,
              ),
          ),
          ' AND ',
        ),
      )
      .then(getOneResult);
  }

  update(
    id: Tokens['id'],
    tokens: {
      attemptsRemaining?: Tokens['attemptsRemaining'];
      created?: Tokens['created'];
      dos?: Tokens['dos'];
      email?: Tokens['email'];
      expiry?: Tokens['expiry'];
      passCodeHash?: Tokens['passCodeHash'];
      state?: Tokens['state'];
      userAgent?: Tokens['userAgent'];
    },
    query?: {
      attemptsRemaining?: Tokens['attemptsRemaining'];
      created?: Tokens['created'];
      dos?: Tokens['dos'];
      email?: Tokens['email'];
      expiry?: Tokens['expiry'];
      passCodeHash?: Tokens['passCodeHash'];
      state?: Tokens['state'];
      userAgent?: Tokens['userAgent'];
    },
  ): Promise<void> {
    const updateColumns = sql.join(
      Object.keys(tokens)
        .sort()
        .filter(
          fieldName =>
            fieldName === 'attemptsRemaining' ||
            fieldName === 'created' ||
            fieldName === 'dos' ||
            fieldName === 'email' ||
            fieldName === 'expiry' ||
            fieldName === 'passCodeHash' ||
            fieldName === 'state' ||
            fieldName === 'userAgent',
        )
        .map(field => sql`${sql.ident(field)} = ${(tokens as any)[field]}`),
      ', ',
    );

    if (query === undefined) {
      return this.db
        .query(sql`UPDATE "Tokens" SET ${updateColumns} WHERE "id" = ${id}`)
        .then(noop);
    }
    return this.db
      .query(
        sql.join(
          [sql`UPDATE "Tokens" SET ${updateColumns} WHERE "id" = ${id}`].concat(
            Object.keys(query)
              .sort()
              .filter(
                fieldName =>
                  fieldName === 'attemptsRemaining' ||
                  fieldName === 'created' ||
                  fieldName === 'dos' ||
                  fieldName === 'email' ||
                  fieldName === 'expiry' ||
                  fieldName === 'passCodeHash' ||
                  fieldName === 'state' ||
                  fieldName === 'userAgent',
              )
              .map(
                field => sql`${sql.ident(field)} = ${(query as any)[field]}`,
              ),
          ),
          ' AND ',
        ),
      )
      .then(noop);
  }

  remove(
    id: Tokens['id'],
    query?: {
      attemptsRemaining?: Tokens['attemptsRemaining'];
      created?: Tokens['created'];
      dos?: Tokens['dos'];
      email?: Tokens['email'];
      expiry?: Tokens['expiry'];
      passCodeHash?: Tokens['passCodeHash'];
      state?: Tokens['state'];
      userAgent?: Tokens['userAgent'];
    },
  ): Promise<void> {
    if (!query) {
      return this.db
        .query(sql`DELETE FROM "Tokens" WHERE "id" = ${id}`)
        .then(noop);
    }
    return this.db
      .query(
        sql.join(
          [sql`DELETE FROM "Tokens" WHERE "id" = ${id}`].concat(
            Object.keys(query)
              .sort()
              .filter(
                fieldName =>
                  fieldName === 'attemptsRemaining' ||
                  fieldName === 'created' ||
                  fieldName === 'dos' ||
                  fieldName === 'email' ||
                  fieldName === 'expiry' ||
                  fieldName === 'passCodeHash' ||
                  fieldName === 'state' ||
                  fieldName === 'userAgent',
              )
              .map(
                field => sql`${sql.ident(field)} = ${(query as any)[field]}`,
              ),
          ),
          ' AND ',
        ),
      )
      .then(noop);
  }
}

export class UserEmailsAPI extends APIBase {
  create(userEmails: {
    email: UserEmails['email'];
    userID: UserEmails['userID'];
  }): Promise<UserEmails> {
    const columns = Object.keys(userEmails)
      .sort()
      .filter(name => name === 'email' || name === 'userID')
      .map(name => ({name, value: (userEmails as any)[name]}));
    const data = columns.length
      ? sql`(${sql.join(
          columns.map(c => sql.ident(c.name)),
          ',',
        )}) VALUES (${sql.join(columns.map(c => sql`${c.value}`), ',')})`
      : sql`DEFAULT VALUES`;
    let s = sql`INSERT INTO "UserEmails" ${data} RETURNING *;`;
    return this.db.query(s).then(results => results[0]);
  }

  where(query: SQLQuery): Promise<UserEmails[]> {
    return this.db.query(
      sql.join([sql`SELECT * FROM "UserEmails"`, query], ' WHERE '),
    );
  }

  list(query?: Partial<UserEmails>): Promise<UserEmails[]> {
    if (query === undefined) {
      return this.db.query(sql`SELECT * FROM "UserEmails"`);
    }
    return this.where(
      sql.join(
        Object.keys(query)
          .sort()
          .filter(fieldName => fieldName === 'email' || fieldName === 'userID')
          .map(field => sql`${sql.ident(field)} = ${(query as any)[field]}`),
        ' AND ',
      ),
    );
  }

  get(
    email: UserEmails['email'],
    query?: {userID?: UserEmails['userID']},
  ): Promise<UserEmails | null> {
    if (query === undefined) {
      return this.db
        .query(sql`SELECT * FROM "UserEmails" WHERE "email" = ${email}`)
        .then(getOneResult);
    }
    return this.db
      .query(
        sql.join(
          [sql`SELECT * FROM "UserEmails" WHERE "email" = ${email}`].concat(
            Object.keys(query)
              .sort()
              .filter(fieldName => fieldName === 'userID')
              .map(
                field => sql`${sql.ident(field)} = ${(query as any)[field]}`,
              ),
          ),
          ' AND ',
        ),
      )
      .then(getOneResult);
  }

  update(
    email: UserEmails['email'],
    userEmails: {userID?: UserEmails['userID']},
    query?: {userID?: UserEmails['userID']},
  ): Promise<void> {
    const updateColumns = sql.join(
      Object.keys(userEmails)
        .sort()
        .filter(fieldName => fieldName === 'userID')
        .map(field => sql`${sql.ident(field)} = ${(userEmails as any)[field]}`),
      ', ',
    );

    if (query === undefined) {
      return this.db
        .query(
          sql`UPDATE "UserEmails" SET ${updateColumns} WHERE "email" = ${email}`,
        )
        .then(noop);
    }
    return this.db
      .query(
        sql.join(
          [
            sql`UPDATE "UserEmails" SET ${updateColumns} WHERE "email" = ${email}`,
          ].concat(
            Object.keys(query)
              .sort()
              .filter(fieldName => fieldName === 'userID')
              .map(
                field => sql`${sql.ident(field)} = ${(query as any)[field]}`,
              ),
          ),
          ' AND ',
        ),
      )
      .then(noop);
  }

  remove(
    email: UserEmails['email'],
    query?: {userID?: UserEmails['userID']},
  ): Promise<void> {
    if (!query) {
      return this.db
        .query(sql`DELETE FROM "UserEmails" WHERE "email" = ${email}`)
        .then(noop);
    }
    return this.db
      .query(
        sql.join(
          [sql`DELETE FROM "UserEmails" WHERE "email" = ${email}`].concat(
            Object.keys(query)
              .sort()
              .filter(fieldName => fieldName === 'userID')
              .map(
                field => sql`${sql.ident(field)} = ${(query as any)[field]}`,
              ),
          ),
          ' AND ',
        ),
      )
      .then(noop);
  }
}

export class UsersAPI extends APIBase {
  create(users: {
    id?: Users['id'];
    name: Users['name'];
    privateStatus?: Users['privateStatus'];
    publicStatus?: Users['publicStatus'];
  }): Promise<Users> {
    const columns = Object.keys(users)
      .sort()
      .filter(
        name =>
          name === 'id' ||
          name === 'name' ||
          name === 'privateStatus' ||
          name === 'publicStatus',
      )
      .map(name => ({name, value: (users as any)[name]}));
    const data = columns.length
      ? sql`(${sql.join(
          columns.map(c => sql.ident(c.name)),
          ',',
        )}) VALUES (${sql.join(columns.map(c => sql`${c.value}`), ',')})`
      : sql`DEFAULT VALUES`;
    let s = sql`INSERT INTO "Users" ${data} RETURNING *;`;
    return this.db.query(s).then(results => results[0]);
  }

  where(query: SQLQuery): Promise<Users[]> {
    return this.db.query(
      sql.join([sql`SELECT * FROM "Users"`, query], ' WHERE '),
    );
  }

  list(query?: Partial<Users>): Promise<Users[]> {
    if (query === undefined) {
      return this.db.query(sql`SELECT * FROM "Users"`);
    }
    return this.where(
      sql.join(
        Object.keys(query)
          .sort()
          .filter(
            fieldName =>
              fieldName === 'id' ||
              fieldName === 'name' ||
              fieldName === 'privateStatus' ||
              fieldName === 'publicStatus',
          )
          .map(field => sql`${sql.ident(field)} = ${(query as any)[field]}`),
        ' AND ',
      ),
    );
  }

  get(
    id: Users['id'],
    query?: {
      name?: Users['name'];
      privateStatus?: Users['privateStatus'];
      publicStatus?: Users['publicStatus'];
    },
  ): Promise<Users | null> {
    if (query === undefined) {
      return this.db
        .query(sql`SELECT * FROM "Users" WHERE "id" = ${id}`)
        .then(getOneResult);
    }
    return this.db
      .query(
        sql.join(
          [sql`SELECT * FROM "Users" WHERE "id" = ${id}`].concat(
            Object.keys(query)
              .sort()
              .filter(
                fieldName =>
                  fieldName === 'name' ||
                  fieldName === 'privateStatus' ||
                  fieldName === 'publicStatus',
              )
              .map(
                field => sql`${sql.ident(field)} = ${(query as any)[field]}`,
              ),
          ),
          ' AND ',
        ),
      )
      .then(getOneResult);
  }

  update(
    id: Users['id'],
    users: {
      name?: Users['name'];
      privateStatus?: Users['privateStatus'];
      publicStatus?: Users['publicStatus'];
    },
    query?: {
      name?: Users['name'];
      privateStatus?: Users['privateStatus'];
      publicStatus?: Users['publicStatus'];
    },
  ): Promise<void> {
    const updateColumns = sql.join(
      Object.keys(users)
        .sort()
        .filter(
          fieldName =>
            fieldName === 'name' ||
            fieldName === 'privateStatus' ||
            fieldName === 'publicStatus',
        )
        .map(field => sql`${sql.ident(field)} = ${(users as any)[field]}`),
      ', ',
    );

    if (query === undefined) {
      return this.db
        .query(sql`UPDATE "Users" SET ${updateColumns} WHERE "id" = ${id}`)
        .then(noop);
    }
    return this.db
      .query(
        sql.join(
          [sql`UPDATE "Users" SET ${updateColumns} WHERE "id" = ${id}`].concat(
            Object.keys(query)
              .sort()
              .filter(
                fieldName =>
                  fieldName === 'name' ||
                  fieldName === 'privateStatus' ||
                  fieldName === 'publicStatus',
              )
              .map(
                field => sql`${sql.ident(field)} = ${(query as any)[field]}`,
              ),
          ),
          ' AND ',
        ),
      )
      .then(noop);
  }

  remove(
    id: Users['id'],
    query?: {
      name?: Users['name'];
      privateStatus?: Users['privateStatus'];
      publicStatus?: Users['publicStatus'];
    },
  ): Promise<void> {
    if (!query) {
      return this.db
        .query(sql`DELETE FROM "Users" WHERE "id" = ${id}`)
        .then(noop);
    }
    return this.db
      .query(
        sql.join(
          [sql`DELETE FROM "Users" WHERE "id" = ${id}`].concat(
            Object.keys(query)
              .sort()
              .filter(
                fieldName =>
                  fieldName === 'name' ||
                  fieldName === 'privateStatus' ||
                  fieldName === 'publicStatus',
              )
              .map(
                field => sql`${sql.ident(field)} = ${(query as any)[field]}`,
              ),
          ),
          ' AND ',
        ),
      )
      .then(noop);
  }
}

export class numbersAPI extends APIBase {
  create(numbers: {
    id?: numbers['id'];
    value: numbers['value'];
  }): Promise<numbers> {
    const columns = Object.keys(numbers)
      .sort()
      .filter(name => name === 'id' || name === 'value')
      .map(name => ({name, value: (numbers as any)[name]}));
    const data = columns.length
      ? sql`(${sql.join(
          columns.map(c => sql.ident(c.name)),
          ',',
        )}) VALUES (${sql.join(columns.map(c => sql`${c.value}`), ',')})`
      : sql`DEFAULT VALUES`;
    let s = sql`INSERT INTO "numbers" ${data} RETURNING *;`;
    return this.db.query(s).then(results => results[0]);
  }

  where(query: SQLQuery): Promise<numbers[]> {
    return this.db.query(
      sql.join([sql`SELECT * FROM "numbers"`, query], ' WHERE '),
    );
  }

  list(query?: Partial<numbers>): Promise<numbers[]> {
    if (query === undefined) {
      return this.db.query(sql`SELECT * FROM "numbers"`);
    }
    return this.where(
      sql.join(
        Object.keys(query)
          .sort()
          .filter(fieldName => fieldName === 'id' || fieldName === 'value')
          .map(field => sql`${sql.ident(field)} = ${(query as any)[field]}`),
        ' AND ',
      ),
    );
  }

  get(
    id: numbers['id'],
    query?: {value?: numbers['value']},
  ): Promise<numbers | null> {
    if (query === undefined) {
      return this.db
        .query(sql`SELECT * FROM "numbers" WHERE "id" = ${id}`)
        .then(getOneResult);
    }
    return this.db
      .query(
        sql.join(
          [sql`SELECT * FROM "numbers" WHERE "id" = ${id}`].concat(
            Object.keys(query)
              .sort()
              .filter(fieldName => fieldName === 'value')
              .map(
                field => sql`${sql.ident(field)} = ${(query as any)[field]}`,
              ),
          ),
          ' AND ',
        ),
      )
      .then(getOneResult);
  }

  update(
    id: numbers['id'],
    numbers: {value?: numbers['value']},
    query?: {value?: numbers['value']},
  ): Promise<void> {
    const updateColumns = sql.join(
      Object.keys(numbers)
        .sort()
        .filter(fieldName => fieldName === 'value')
        .map(field => sql`${sql.ident(field)} = ${(numbers as any)[field]}`),
      ', ',
    );

    if (query === undefined) {
      return this.db
        .query(sql`UPDATE "numbers" SET ${updateColumns} WHERE "id" = ${id}`)
        .then(noop);
    }
    return this.db
      .query(
        sql.join(
          [
            sql`UPDATE "numbers" SET ${updateColumns} WHERE "id" = ${id}`,
          ].concat(
            Object.keys(query)
              .sort()
              .filter(fieldName => fieldName === 'value')
              .map(
                field => sql`${sql.ident(field)} = ${(query as any)[field]}`,
              ),
          ),
          ' AND ',
        ),
      )
      .then(noop);
  }

  remove(id: numbers['id'], query?: {value?: numbers['value']}): Promise<void> {
    if (!query) {
      return this.db
        .query(sql`DELETE FROM "numbers" WHERE "id" = ${id}`)
        .then(noop);
    }
    return this.db
      .query(
        sql.join(
          [sql`DELETE FROM "numbers" WHERE "id" = ${id}`].concat(
            Object.keys(query)
              .sort()
              .filter(fieldName => fieldName === 'value')
              .map(
                field => sql`${sql.ident(field)} = ${(query as any)[field]}`,
              ),
          ),
          ' AND ',
        ),
      )
      .then(noop);
  }
}

export default class Database extends APIBase {
  private _MopedMigrations: MopedMigrationsAPI | void;
  private _MopedMigrationsVersion: MopedMigrationsVersionAPI | void;
  private _RateLimitStates: RateLimitStatesAPI | void;
  private _Sessions: SessionsAPI | void;
  private _Tokens: TokensAPI | void;
  private _UserEmails: UserEmailsAPI | void;
  private _Users: UsersAPI | void;
  private _numbers: numbersAPI | void;

  get MopedMigrations(): MopedMigrationsAPI {
    return (
      this._MopedMigrations ||
      (this._MopedMigrations = new MopedMigrationsAPI(this.db))
    );
  }

  get MopedMigrationsVersion(): MopedMigrationsVersionAPI {
    return (
      this._MopedMigrationsVersion ||
      (this._MopedMigrationsVersion = new MopedMigrationsVersionAPI(this.db))
    );
  }

  get RateLimitStates(): RateLimitStatesAPI {
    return (
      this._RateLimitStates ||
      (this._RateLimitStates = new RateLimitStatesAPI(this.db))
    );
  }

  get Sessions(): SessionsAPI {
    return this._Sessions || (this._Sessions = new SessionsAPI(this.db));
  }

  get Tokens(): TokensAPI {
    return this._Tokens || (this._Tokens = new TokensAPI(this.db));
  }

  get UserEmails(): UserEmailsAPI {
    return this._UserEmails || (this._UserEmails = new UserEmailsAPI(this.db));
  }

  get Users(): UsersAPI {
    return this._Users || (this._Users = new UsersAPI(this.db));
  }

  get numbers(): numbersAPI {
    return this._numbers || (this._numbers = new numbersAPI(this.db));
  }

  task<T>(fn: (connection: Database) => Promise<T>): Promise<T> {
    return this.db.task(db => fn(new Database(db)));
  }
  tx<T>(fn: (connection: Database) => Promise<T>): Promise<T> {
    return this.db.tx(db => fn(new Database(db)));
  }
}
