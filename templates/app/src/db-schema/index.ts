// Auto generated by @moped/db-schema - do not edit by hand

import sql, {SQLQuery} from '@moped/sql';
import MopedMigrations from './tables/MopedMigrations';
import Sessions from './tables/Sessions';
import Users from './tables/Users';

function getOneResult<T>(results: T[]): T | null {
  if (results.length === 0) {
    return null;
  }
  if (results.length === 1) {
    return results[0];
  }
  throw new Error(
    'Expected either one result, or no results to be returned from this query',
  );
}
function noop(): void {}
export interface Connection {
  query(query: SQLQuery): Promise<any[]>;
  task<T>(fn: (connection: Connection) => Promise<T>): Promise<T>;
  tx<T>(fn: (connection: Connection) => Promise<T>): Promise<T>;
}
export class APIBase {
  protected db: Connection;
  constructor(db: Connection) {
    this.db = db;
  }
}

export class MopedMigrationsAPI extends APIBase {
  create(mopedMigrations: {
    id: MopedMigrations['id'];
    isApplied?: MopedMigrations['isApplied'];
    lastDown?: MopedMigrations['lastDown'];
    lastUp?: MopedMigrations['lastUp'];
    name: MopedMigrations['name'];
  }): Promise<MopedMigrations> {
    const columns = Object.keys(mopedMigrations)
      .sort()
      .filter(
        name =>
          name === 'id' ||
          name === 'isApplied' ||
          name === 'lastDown' ||
          name === 'lastUp' ||
          name === 'name',
      )
      .map(name => ({name, value: (mopedMigrations as any)[name]}));
    const data = columns.length
      ? sql`(${sql.join(
          columns.map(c => sql.ident(c.name)),
          ',',
        )}) VALUES (${sql.join(columns.map(c => sql`${c.value}`), ',')})`
      : sql`DEFAULT VALUES`;
    let s = sql`INSERT INTO "MopedMigrations" ${data} RETURNING *;`;
    return this.db.query(s).then(results => results[0]);
  }

  where(query: SQLQuery): Promise<MopedMigrations[]> {
    return this.db.query(
      sql.join([sql`SELECT * FROM "MopedMigrations"`, query], ' WHERE '),
    );
  }

  list(query?: Partial<MopedMigrations>): Promise<MopedMigrations[]> {
    if (query === undefined) {
      return this.db.query(sql`SELECT * FROM "MopedMigrations"`);
    }
    return this.where(
      sql.join(
        Object.keys(query)
          .sort()
          .filter(
            fieldName =>
              fieldName === 'id' ||
              fieldName === 'isApplied' ||
              fieldName === 'lastDown' ||
              fieldName === 'lastUp' ||
              fieldName === 'name',
          )
          .map(field => sql`${sql.ident(field)} = ${(query as any)[field]}`),
        ' AND ',
      ),
    );
  }

  get(
    id: MopedMigrations['id'],
    query?: {
      isApplied?: MopedMigrations['isApplied'];
      lastDown?: MopedMigrations['lastDown'];
      lastUp?: MopedMigrations['lastUp'];
      name?: MopedMigrations['name'];
    },
  ): Promise<MopedMigrations | null> {
    if (query === undefined) {
      return this.db
        .query(sql`SELECT * FROM "MopedMigrations" WHERE "id" = ${id}`)
        .then(getOneResult);
    }
    return this.db
      .query(
        sql.join(
          [sql`SELECT * FROM "MopedMigrations" WHERE "id" = ${id}`].concat(
            Object.keys(query)
              .sort()
              .filter(
                fieldName =>
                  fieldName === 'isApplied' ||
                  fieldName === 'lastDown' ||
                  fieldName === 'lastUp' ||
                  fieldName === 'name',
              )
              .map(
                field => sql`${sql.ident(field)} = ${(query as any)[field]}`,
              ),
          ),
          ' AND ',
        ),
      )
      .then(getOneResult);
  }

  update(
    id: MopedMigrations['id'],
    mopedMigrations: {
      isApplied?: MopedMigrations['isApplied'];
      lastDown?: MopedMigrations['lastDown'];
      lastUp?: MopedMigrations['lastUp'];
      name?: MopedMigrations['name'];
    },
    query?: {
      isApplied?: MopedMigrations['isApplied'];
      lastDown?: MopedMigrations['lastDown'];
      lastUp?: MopedMigrations['lastUp'];
      name?: MopedMigrations['name'];
    },
  ): Promise<void> {
    const updateColumns = sql.join(
      Object.keys(mopedMigrations)
        .sort()
        .filter(
          fieldName =>
            fieldName === 'isApplied' ||
            fieldName === 'lastDown' ||
            fieldName === 'lastUp' ||
            fieldName === 'name',
        )
        .map(
          field =>
            sql`${sql.ident(field)} = ${(mopedMigrations as any)[field]}`,
        ),
      ', ',
    );

    if (query === undefined) {
      return this.db
        .query(
          sql`UPDATE "MopedMigrations" SET ${updateColumns} WHERE "id" = ${id}`,
        )
        .then(noop);
    }
    return this.db
      .query(
        sql.join(
          [
            sql`UPDATE "MopedMigrations" SET ${updateColumns} WHERE "id" = ${id}`,
          ].concat(
            Object.keys(query)
              .sort()
              .filter(
                fieldName =>
                  fieldName === 'isApplied' ||
                  fieldName === 'lastDown' ||
                  fieldName === 'lastUp' ||
                  fieldName === 'name',
              )
              .map(
                field => sql`${sql.ident(field)} = ${(query as any)[field]}`,
              ),
          ),
          ' AND ',
        ),
      )
      .then(noop);
  }

  remove(
    id: MopedMigrations['id'],
    query?: {
      isApplied?: MopedMigrations['isApplied'];
      lastDown?: MopedMigrations['lastDown'];
      lastUp?: MopedMigrations['lastUp'];
      name?: MopedMigrations['name'];
    },
  ): Promise<void> {
    if (!query) {
      return this.db
        .query(sql`DELETE FROM "MopedMigrations" WHERE "id" = ${id}`)
        .then(noop);
    }
    return this.db
      .query(
        sql.join(
          [sql`DELETE FROM "MopedMigrations" WHERE "id" = ${id}`].concat(
            Object.keys(query)
              .sort()
              .filter(
                fieldName =>
                  fieldName === 'isApplied' ||
                  fieldName === 'lastDown' ||
                  fieldName === 'lastUp' ||
                  fieldName === 'name',
              )
              .map(
                field => sql`${sql.ident(field)} = ${(query as any)[field]}`,
              ),
          ),
          ' AND ',
        ),
      )
      .then(noop);
  }
}

export class SessionsAPI extends APIBase {
  create(sessions: {
    created: Sessions['created'];
    id?: Sessions['id'];
    lastSeen: Sessions['lastSeen'];
    userAgent?: Sessions['userAgent'];
    userID: Sessions['userID'];
  }): Promise<Sessions> {
    const columns = Object.keys(sessions)
      .sort()
      .filter(
        name =>
          name === 'created' ||
          name === 'id' ||
          name === 'lastSeen' ||
          name === 'userAgent' ||
          name === 'userID',
      )
      .map(name => ({name, value: (sessions as any)[name]}));
    const data = columns.length
      ? sql`(${sql.join(
          columns.map(c => sql.ident(c.name)),
          ',',
        )}) VALUES (${sql.join(columns.map(c => sql`${c.value}`), ',')})`
      : sql`DEFAULT VALUES`;
    let s = sql`INSERT INTO "Sessions" ${data} RETURNING *;`;
    return this.db.query(s).then(results => results[0]);
  }

  where(query: SQLQuery): Promise<Sessions[]> {
    return this.db.query(
      sql.join([sql`SELECT * FROM "Sessions"`, query], ' WHERE '),
    );
  }

  list(query?: Partial<Sessions>): Promise<Sessions[]> {
    if (query === undefined) {
      return this.db.query(sql`SELECT * FROM "Sessions"`);
    }
    return this.where(
      sql.join(
        Object.keys(query)
          .sort()
          .filter(
            fieldName =>
              fieldName === 'created' ||
              fieldName === 'id' ||
              fieldName === 'lastSeen' ||
              fieldName === 'userAgent' ||
              fieldName === 'userID',
          )
          .map(field => sql`${sql.ident(field)} = ${(query as any)[field]}`),
        ' AND ',
      ),
    );
  }

  get(
    id: Sessions['id'],
    query?: {
      created?: Sessions['created'];
      lastSeen?: Sessions['lastSeen'];
      userAgent?: Sessions['userAgent'];
      userID?: Sessions['userID'];
    },
  ): Promise<Sessions | null> {
    if (query === undefined) {
      return this.db
        .query(sql`SELECT * FROM "Sessions" WHERE "id" = ${id}`)
        .then(getOneResult);
    }
    return this.db
      .query(
        sql.join(
          [sql`SELECT * FROM "Sessions" WHERE "id" = ${id}`].concat(
            Object.keys(query)
              .sort()
              .filter(
                fieldName =>
                  fieldName === 'created' ||
                  fieldName === 'lastSeen' ||
                  fieldName === 'userAgent' ||
                  fieldName === 'userID',
              )
              .map(
                field => sql`${sql.ident(field)} = ${(query as any)[field]}`,
              ),
          ),
          ' AND ',
        ),
      )
      .then(getOneResult);
  }

  update(
    id: Sessions['id'],
    sessions: {
      created?: Sessions['created'];
      lastSeen?: Sessions['lastSeen'];
      userAgent?: Sessions['userAgent'];
      userID?: Sessions['userID'];
    },
    query?: {
      created?: Sessions['created'];
      lastSeen?: Sessions['lastSeen'];
      userAgent?: Sessions['userAgent'];
      userID?: Sessions['userID'];
    },
  ): Promise<void> {
    const updateColumns = sql.join(
      Object.keys(sessions)
        .sort()
        .filter(
          fieldName =>
            fieldName === 'created' ||
            fieldName === 'lastSeen' ||
            fieldName === 'userAgent' ||
            fieldName === 'userID',
        )
        .map(field => sql`${sql.ident(field)} = ${(sessions as any)[field]}`),
      ', ',
    );

    if (query === undefined) {
      return this.db
        .query(sql`UPDATE "Sessions" SET ${updateColumns} WHERE "id" = ${id}`)
        .then(noop);
    }
    return this.db
      .query(
        sql.join(
          [
            sql`UPDATE "Sessions" SET ${updateColumns} WHERE "id" = ${id}`,
          ].concat(
            Object.keys(query)
              .sort()
              .filter(
                fieldName =>
                  fieldName === 'created' ||
                  fieldName === 'lastSeen' ||
                  fieldName === 'userAgent' ||
                  fieldName === 'userID',
              )
              .map(
                field => sql`${sql.ident(field)} = ${(query as any)[field]}`,
              ),
          ),
          ' AND ',
        ),
      )
      .then(noop);
  }

  remove(
    id: Sessions['id'],
    query?: {
      created?: Sessions['created'];
      lastSeen?: Sessions['lastSeen'];
      userAgent?: Sessions['userAgent'];
      userID?: Sessions['userID'];
    },
  ): Promise<void> {
    if (!query) {
      return this.db
        .query(sql`DELETE FROM "Sessions" WHERE "id" = ${id}`)
        .then(noop);
    }
    return this.db
      .query(
        sql.join(
          [sql`DELETE FROM "Sessions" WHERE "id" = ${id}`].concat(
            Object.keys(query)
              .sort()
              .filter(
                fieldName =>
                  fieldName === 'created' ||
                  fieldName === 'lastSeen' ||
                  fieldName === 'userAgent' ||
                  fieldName === 'userID',
              )
              .map(
                field => sql`${sql.ident(field)} = ${(query as any)[field]}`,
              ),
          ),
          ' AND ',
        ),
      )
      .then(noop);
  }
}

export class UsersAPI extends APIBase {
  create(users: {id?: Users['id']; name: Users['name']}): Promise<Users> {
    const columns = Object.keys(users)
      .sort()
      .filter(name => name === 'id' || name === 'name')
      .map(name => ({name, value: (users as any)[name]}));
    const data = columns.length
      ? sql`(${sql.join(
          columns.map(c => sql.ident(c.name)),
          ',',
        )}) VALUES (${sql.join(columns.map(c => sql`${c.value}`), ',')})`
      : sql`DEFAULT VALUES`;
    let s = sql`INSERT INTO "Users" ${data} RETURNING *;`;
    return this.db.query(s).then(results => results[0]);
  }

  where(query: SQLQuery): Promise<Users[]> {
    return this.db.query(
      sql.join([sql`SELECT * FROM "Users"`, query], ' WHERE '),
    );
  }

  list(query?: Partial<Users>): Promise<Users[]> {
    if (query === undefined) {
      return this.db.query(sql`SELECT * FROM "Users"`);
    }
    return this.where(
      sql.join(
        Object.keys(query)
          .sort()
          .filter(fieldName => fieldName === 'id' || fieldName === 'name')
          .map(field => sql`${sql.ident(field)} = ${(query as any)[field]}`),
        ' AND ',
      ),
    );
  }

  get(id: Users['id'], query?: {name?: Users['name']}): Promise<Users | null> {
    if (query === undefined) {
      return this.db
        .query(sql`SELECT * FROM "Users" WHERE "id" = ${id}`)
        .then(getOneResult);
    }
    return this.db
      .query(
        sql.join(
          [sql`SELECT * FROM "Users" WHERE "id" = ${id}`].concat(
            Object.keys(query)
              .sort()
              .filter(fieldName => fieldName === 'name')
              .map(
                field => sql`${sql.ident(field)} = ${(query as any)[field]}`,
              ),
          ),
          ' AND ',
        ),
      )
      .then(getOneResult);
  }

  update(
    id: Users['id'],
    users: {name?: Users['name']},
    query?: {name?: Users['name']},
  ): Promise<void> {
    const updateColumns = sql.join(
      Object.keys(users)
        .sort()
        .filter(fieldName => fieldName === 'name')
        .map(field => sql`${sql.ident(field)} = ${(users as any)[field]}`),
      ', ',
    );

    if (query === undefined) {
      return this.db
        .query(sql`UPDATE "Users" SET ${updateColumns} WHERE "id" = ${id}`)
        .then(noop);
    }
    return this.db
      .query(
        sql.join(
          [sql`UPDATE "Users" SET ${updateColumns} WHERE "id" = ${id}`].concat(
            Object.keys(query)
              .sort()
              .filter(fieldName => fieldName === 'name')
              .map(
                field => sql`${sql.ident(field)} = ${(query as any)[field]}`,
              ),
          ),
          ' AND ',
        ),
      )
      .then(noop);
  }

  remove(id: Users['id'], query?: {name?: Users['name']}): Promise<void> {
    if (!query) {
      return this.db
        .query(sql`DELETE FROM "Users" WHERE "id" = ${id}`)
        .then(noop);
    }
    return this.db
      .query(
        sql.join(
          [sql`DELETE FROM "Users" WHERE "id" = ${id}`].concat(
            Object.keys(query)
              .sort()
              .filter(fieldName => fieldName === 'name')
              .map(
                field => sql`${sql.ident(field)} = ${(query as any)[field]}`,
              ),
          ),
          ' AND ',
        ),
      )
      .then(noop);
  }
}

export default class Database extends APIBase {
  private _MopedMigrations: MopedMigrationsAPI | void;
  private _Sessions: SessionsAPI | void;
  private _Users: UsersAPI | void;

  get MopedMigrations(): MopedMigrationsAPI {
    return (
      this._MopedMigrations ||
      (this._MopedMigrations = new MopedMigrationsAPI(this.db))
    );
  }

  get Sessions(): SessionsAPI {
    return this._Sessions || (this._Sessions = new SessionsAPI(this.db));
  }

  get Users(): UsersAPI {
    return this._Users || (this._Users = new UsersAPI(this.db));
  }

  task<T>(fn: (connection: Database) => Promise<T>): Promise<T> {
    return this.db.task(db => fn(new Database(db)));
  }
  tx<T>(fn: (connection: Database) => Promise<T>): Promise<T> {
    return this.db.tx(db => fn(new Database(db)));
  }
}
